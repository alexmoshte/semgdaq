/*
 * _ADCn_INx_STFT.c
 *
 * Created on: Oct 14, 2024
 * Author: Mwangi Alex. W
 */

//INCLUDES
#include "_ADCn_INx_STFT.h"

arm_rfft_fast_instance_f32  ADC1_IN1_FFT;
arm_rfft_fast_instance_f32  ADC1_IN2_FFT;
arm_rfft_fast_instance_f32  ADC2_IN3_FFT;
arm_rfft_fast_instance_f32  ADC2_IN4_FFT;
arm_rfft_fast_instance_f32  ADC3_IN1_FFT;
arm_rfft_fast_instance_f32  ADC3_IN2_FFT;


float32_t FFT_Mag_Res_1[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];
float32_t FFT_Mag_Res_2[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];
float32_t FFT_Mag_Res_3[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];
float32_t FFT_Mag_Res_4[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];
float32_t FFT_Mag_Res_5[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];
float32_t FFT_Mag_Res_6[ADC_DMA_SIXTEENTHBUFFERSIZE / 2];


//FUNCTION DEFINITIONS
float32_t* ADC1_IN1_STFT_Update(ADC1_IN1_STFT_par*ADC1_IN1_STFT_par_ptr, ADC1_IN1_MA*ADC1_IN1_STFT_ptr)
{
	ADC1_IN1_STFT_par_ptr->Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6); // The Gaussian window spans about + or - 3 * Sigma_1 from the mean (center of the window). Setting Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6) ensures that almost all of the window (99.7%) lies within the buffer
	ADC1_IN1_STFT_par_ptr->mu_1 = ((ADC_DMA_SIXTEENTHBUFFERSIZE-1)/(2.0f));

    /* Generating the Gaussian window*/
	for(uint32_t n = 0; n < ADC_DMA_SIXTEENTHBUFFERSIZE; n++)
	{
		float32_t exponent_1 = -0.5f*(pow(((n - ADC1_IN1_STFT_par_ptr->mu_1)/ADC1_IN1_STFT_par_ptr->Sigma_1), 2));
		ADC1_IN1_STFT_par_ptr->Gaussian_Win_1[n] = exp(exponent_1);
	}

	/* Windows the moving average output buffer with the Gaussian window */
	for (uint32_t m = 0; m < ADC_DMA_SIXTEENTHBUFFERSIZE; m++)
	{
		ADC1_IN1_STFT_par_ptr->Windowed_STFT_bfr_1[m] = ADC1_IN1_STFT_ptr->MA_ADC1_IN1_OutBfr[m] * ADC1_IN1_STFT_par_ptr->Gaussian_Win_1[m];
	}

	arm_status FFT_status_1 = arm_rfft_fast_init_f32 (&ADC1_IN1_FFT, ADC_DMA_SIXTEENTHBUFFERSIZE);

	if (FFT_status_1 == ARM_MATH_SUCCESS)
	{
		arm_rfft_fast_f32 (&ADC1_IN1_FFT, ADC1_IN1_STFT_par_ptr->Windowed_STFT_bfr_1 , ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr, 0 );

		uint32_t mag_indx_1 = 0.0f;

		for (uint32_t p; p < ADC_DMA_SIXTEENTHBUFFERSIZE; p += 2)
		{
			FFT_Mag_Res_1[mag_indx_1] = sqrtf((ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr[p] * ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr[p]) + (ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr[p+1] * ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr[p+1]));

			mag_indx_1++;
		}
	}

	return FFT_Mag_Res_1;
}

float32_t* ADC1_IN2_STFT_Update(ADC1_IN2_STFT_par*ADC1_IN2_STFT_par_ptr, ADC1_IN2_MA*ADC1_IN2_STFT_ptr)
{
	ADC1_IN2_STFT_par_ptr->Sigma_2 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6); // The Gaussian window spans about + or - 3 * Sigma_1 from the mean (center of the window). Setting Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6) ensures that almost all of the window (99.7%) lies within the buffer
	ADC1_IN2_STFT_par_ptr->mu_2 = ((ADC_DMA_SIXTEENTHBUFFERSIZE-1)/(2.0f));

    /* Generating the Gaussian window*/
	for(uint32_t n = 0; n < ADC_DMA_SIXTEENTHBUFFERSIZE; n++)
	{
		float32_t exponent_2 = -0.5f*(pow(((n - ADC1_IN2_STFT_par_ptr->mu_2)/ADC1_IN2_STFT_par_ptr->Sigma_2), 2));
		ADC1_IN2_STFT_par_ptr->Gaussian_Win_2[n] = exp(exponent_2);
	}

	/* Windows the moving average output buffer with the Gaussian window */
	for (uint32_t m = 0; m < ADC_DMA_SIXTEENTHBUFFERSIZE; m++)
	{
		ADC1_IN2_STFT_par_ptr->Windowed_STFT_bfr_2[m] = ADC1_IN2_STFT_ptr->MA_ADC1_IN2_OutBfr[m] * ADC1_IN2_STFT_par_ptr->Gaussian_Win_2[m];
	}

	arm_status FFT_status_2 = arm_rfft_fast_init_f32 (&ADC1_IN2_FFT, ADC_DMA_SIXTEENTHBUFFERSIZE);

	if (FFT_status_2 == ARM_MATH_SUCCESS)
	{
		arm_rfft_fast_f32 (&ADC1_IN2_FFT, ADC1_IN2_STFT_par_ptr->Windowed_STFT_bfr_2 , ADC1_IN2_STFT_par_ptr->ADC1_IN2_FFT_Out_bfr, 0 );

		uint32_t mag_indx_2 = 0.0f;

		for (uint32_t p; p < ADC_DMA_SIXTEENTHBUFFERSIZE; p += 2)
		{
			FFT_Mag_Res_2[mag_indx_2] = sqrtf((ADC1_IN2_STFT_par_ptr->ADC1_IN2_FFT_Out_bfr[p] * ADC1_IN2_STFT_par_ptr->ADC1_IN2_FFT_Out_bfr[p]) + (ADC1_IN2_STFT_par_ptr->ADC1_IN2_FFT_Out_bfr[p+1] * ADC1_IN2_STFT_par_ptr->ADC1_IN2_FFT_Out_bfr[p+1]));

			mag_indx_2++;
		}
	}

	return FFT_Mag_Res_2;
}

float32_t* ADC2_IN3_STFT_Update(ADC2_IN3_STFT_par*ADC2_IN3_STFT_par_ptr, ADC2_IN3_MA*ADC2_IN3_STFT_ptr)
{
	ADC2_IN3_STFT_par_ptr->Sigma_3 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6); // The Gaussian window spans about + or - 3 * Sigma_1 from the mean (center of the window). Setting Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6) ensures that almost all of the window (99.7%) lies within the buffer
	ADC2_IN3_STFT_par_ptr->mu_3 = ((ADC_DMA_SIXTEENTHBUFFERSIZE-1)/(2.0f));

    /* Generating the Gaussian window*/
	for(uint32_t n = 0; n < ADC_DMA_SIXTEENTHBUFFERSIZE; n++)
	{
		float32_t exponent_3 = -0.5f*(pow(((n - ADC2_IN3_STFT_par_ptr->mu_3)/ADC2_IN3_STFT_par_ptr->Sigma_3), 2));
		ADC2_IN3_STFT_par_ptr->Gaussian_Win_3[n] = exp(exponent_3);
	}

	/* Windows the moving average output buffer with the Gaussian window */
	for (uint32_t m = 0; m < ADC_DMA_SIXTEENTHBUFFERSIZE; m++)
	{
		ADC2_IN3_STFT_par_ptr->Windowed_STFT_bfr_3[m] = ADC2_IN3_STFT_ptr->MA_ADC2_IN3_OutBfr[m] * ADC2_IN3_STFT_par_ptr->Gaussian_Win_3[m];
	}

	arm_status FFT_status_3 = arm_rfft_fast_init_f32 (&ADC2_IN3_FFT, ADC_DMA_SIXTEENTHBUFFERSIZE);

	if (FFT_status_3 == ARM_MATH_SUCCESS)
	{
		arm_rfft_fast_f32 (&ADC2_IN3_FFT, ADC2_IN3_STFT_par_ptr->Windowed_STFT_bfr_3 , ADC2_IN3_STFT_par_ptr->ADC2_IN3_FFT_Out_bfr, 0 );

		uint32_t mag_indx_3 = 0.0f;

		for (uint32_t p; p < ADC_DMA_SIXTEENTHBUFFERSIZE; p += 2)
		{
			FFT_Mag_Res_3[mag_indx_3] = sqrtf((ADC2_IN3_STFT_par_ptr->ADC2_IN3_FFT_Out_bfr[p] * ADC2_IN3_STFT_par_ptr->ADC2_IN3_FFT_Out_bfr[p]) + (ADC2_IN3_STFT_par_ptr->ADC2_IN3_FFT_Out_bfr[p+1] * ADC2_IN3_STFT_par_ptr->ADC2_IN3_FFT_Out_bfr[p+1]));

			mag_indx_3++;
		}
	}

	return FFT_Mag_Res_3;
}


