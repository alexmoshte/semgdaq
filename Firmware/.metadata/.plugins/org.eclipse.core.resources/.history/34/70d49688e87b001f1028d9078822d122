/*
 * _ADCn_INx_MA.c
 *
 *  Created on: Sep 25, 2024
 *  Author: Mwangi Alex. W
 *
 *
 *
 */
#include "_ADCn_INx_MA.h"

static float32_t  MA_IMPULSERESPONSE[MA_FILTER_LENGTH]={0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f};

void MA_ADC1_IN1_Init (ADC1_IN1_MA *ADC1_IN1_MA_ptr)
{
	for(uint8_t j=0; j< MA_FILTER_LENGTH; j++)
	{
        ADC1_IN1_MA_ptr->_MA_IR_ADC1_IN1_bfr[j]=0.0f;
    }


	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx=0;


	for (uint32_t i=0; i <ADC_DMA_HALFBUFFERSIZE; i++)
	{
	    ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[i] = 0.0f;  // Set each element to 0.0f
	}
}


float32_t MA_ADC1_IN1_Update (ADC1_IN1_MA *ADC1_IN1_MA_ptr, float32_t* InpBfr, float32_t* OutBfr)
{
    for (uint32_t u=0; u<ADC_DMA_HALFBUFFERSIZE; u++ )

    {
    	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx]=InpBfr[u];

    	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx++;


    	if (ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx == MA_FILTER_LENGTH)
    	{
    		ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx = 0;
    	}

    	OutBfr[u] = 0;

    	uint8_t SumIndex = ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx;

    	for(uint8_t r = 0; r< MA_FILTER_LENGTH; r++ )
    	{
    		if (sumIndex > 0)
    		{
    		     sumIndex--;
    		}

    		else
    		{
    		     sumIndex = MA_FILTER_LENGTH - 1;
    	    }
    	}

    	OutBfr[u] +=  MA_IMPULSERESPONSE[u] * ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[sumIndex];

    }


}
