/*
 * _ADCn_INx_STFT.c
 *
 * Created on: Oct 14, 2024
 * Author: Mwangi Alex. W
 */

//INCLUDES
#include "_ADCn_INx_STFT.h"

arm_rfft_fast_instance_f32  ADC1_IN1_FFT;
arm_rfft_fast_instance_f32  ADC1_IN2_FFT;
arm_rfft_fast_instance_f32  ADC2_IN3_FFT;
arm_rfft_fast_instance_f32  ADC2_IN4_FFT;
arm_rfft_fast_instance_f32  ADC3_IN1_FFT;
arm_rfft_fast_instance_f32  ADC3_IN2_FFT;


//FUNCTION DEFINITIONS
void ADC1_IN1_STFT_Update(ADC1_IN1_STFT_par*ADC1_IN1_STFT_par_ptr, ADC1_IN1_MA*ADC1_IN1_STFT_ptr)
{
	ADC1_IN1_STFT_par_ptr->Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6); // The Gaussian window spans about + or - 3 * Sigma_1 from the mean (center of the window). Setting Sigma_1 = (ADC_DMA_SIXTEENTHBUFFERSIZE / 6) ensures that almost all of the window (99.7%) lies within the buffer
	ADC1_IN1_STFT_par_ptr->mu_1 = ((ADC_DMA_SIXTEENTHBUFFERSIZE-1)/(2.0f));

    /* Generating the Gaussian window*/
	for(uint32_t n = 0; n < ADC_DMA_SIXTEENTHBUFFERSIZE; n++)
	{
		float32_t exponent_1 = -0.5f*(pow(((n - ADC1_IN1_STFT_par_ptr->mu_1)/ADC1_IN1_STFT_par_ptr->Sigma_1), 2));
		ADC1_IN1_STFT_par_ptr->Gaussian_Win_1[n] = exp(exponent_1);
	}

	/* Windows the moving average output buffer with the Gaussian window */
	for (uint32_t m = 0; m < ADC_DMA_SIXTEENTHBUFFERSIZE; m++)
	{
		ADC1_IN1_STFT_par_ptr->Windowed_STFT_bfr_1[m] = ADC1_IN1_STFT_par_ptr->Gaussian_Win_1[m] * ADC1_IN1_STFT_ptr->MA_ADC1_IN1_OutBfr[m];
	}

	arm_status FFT_status_1 = arm_rfft_256_fast_init_f32 (&ADC1_IN1_FFT);

	if (FFT_status_1 == ARM_MATH_SUCCESS)
	{
		arm_rfft_fast_f32 (&ADC1_IN1_FFT, ADC1_IN1_STFT_ptr->MA_ADC1_IN1_OutBfr,ADC1_IN1_STFT_par_ptr->ADC1_IN1_FFT_Out_bfr, 0 );
	}

}


