/*
 * _ADCn_INx_MA.c
 *
 *  Created on: Sep 25, 2024
 *  Author: Mwangi Alex. W
 *
 *
 *
 */
#include "_ADCn_INx_MA.h"

static float32_t  MA_IMPULSERESPONSE[MA_FILTER_LENGTH]={0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f, 0.125f};

void MA_ADC1_IN1_Init (ADC1_IN1_MA *ADC1_IN1_MA_ptr)
{

	for(uint8_t j=0; j< MA_FILTER_LENGTH; j++)
	{
        ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[j]=0.0f;
    }


	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx=0;


	for (uint32_t i=0; i <ADC_DMA_HALFBUFFERSIZE; i++)
	{
	    ADC1_IN1_MA_ptr->MA_ADC1_IN1_OutBfr[i] = 0.0f;  // Set each element to 0.0f
	}
}


void MA_ADC1_IN1_Update (ADC1_IN1_MA *ADC1_IN1_MA_ptr, float32_t* InpBfr_1, float32_t* OutBfr_1)
{
    for (uint32_t u=0; u<ADC_DMA_HALFBUFFERSIZE; u++ )

    {
    	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx]=InpBfr_1[u];

    	ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx++;


    	if (ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx == MA_FILTER_LENGTH)
    	{
    		ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx = 0;
    	}

    	OutBfr_1[u] = 0.0f;

    	uint8_t SumIndex_1 = ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr_indx;

    	for(uint8_t r = 0; r< MA_FILTER_LENGTH; r++ )
    	{
    		if (SumIndex_1 > 0)
    		{
    		     SumIndex_1--;
    		}

    		else
    		{
    		     SumIndex_1 = MA_FILTER_LENGTH - 1;
    	    }
    	}

    	OutBfr_1[u] +=  MA_IMPULSERESPONSE[u] * ADC1_IN1_MA_ptr->MA_ADC1_IN1_bfr[SumIndex_1];

    }


}
